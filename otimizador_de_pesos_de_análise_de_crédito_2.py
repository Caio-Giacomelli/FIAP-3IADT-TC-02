# -*- coding: utf-8 -*-
"""Otimizador de Pesos de Análise de Crédito - 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lPVvqU6hSxzZUiLQYmEA9ivN4b4sL_8W

# Importação de bibliotecas e dados
"""

import numpy as np
import pandas as pd
import seaborn as sns
import pygame
from pygame.locals import *
import matplotlib.pyplot as plt
from sklearn.metrics import f1_score

full_dt = pd.read_csv('https://raw.githubusercontent.com/Caio-Giacomelli/FIAP-3IADT-TC-02/refs/heads/main/credit_analysis_train.csv')

full_dt.info()

"""# Análise e Tratamento de dados"""

# Removendo colunas que não utilizaremos em nossa otimização
columns_to_remove = ['ID', 'Age', 'Customer_ID', 'Month', 'Name', 'SSN', 'Type_of_Loan', 'Occupation', 'Delay_from_due_date', 'Monthly_Inhand_Salary', 'Changed_Credit_Limit', 'Num_Credit_Inquiries', 'Credit_Mix', 'Credit_History_Age','Payment_of_Min_Amount','Total_EMI_per_month','Amount_invested_monthly', 'Payment_Behaviour', 'Outstanding_Debt', 'Credit_Utilization_Ratio', 'Monthly_Balance']
dt = full_dt.drop(columns=columns_to_remove)

dt.duplicated().sum()

dt.drop_duplicates(inplace=True)
dt.shape

# Removendo valores nulos ou mal formatados

dt = dt.replace('_', '', regex=True)

# Transformando colunas de strings para numérico
dt['Num_of_Delayed_Payment'] = pd.to_numeric(dt['Num_of_Delayed_Payment'], errors='coerce')
dt['Num_of_Loan'] = pd.to_numeric(dt['Num_of_Loan'], errors='coerce')
dt['Annual_Income'] = pd.to_numeric(dt['Annual_Income'], errors='coerce')

# Removendo registros com valores discrepantes demais
dt_filtrado = dt.copy()
dt_filtrado = dt_filtrado[dt_filtrado['Num_of_Delayed_Payment'] <= 30]
dt_filtrado = dt_filtrado[(dt_filtrado['Num_of_Loan'] > 0) & (dt_filtrado['Num_of_Loan'] <= 30)]
dt_filtrado = dt_filtrado[dt_filtrado['Interest_Rate'] <= 100]
dt_filtrado = dt_filtrado[dt_filtrado['Num_Bank_Accounts'] <= 30]
dt_filtrado = dt_filtrado[dt_filtrado['Num_Credit_Card'] <= 30]
dt_filtrado = dt_filtrado[dt_filtrado['Annual_Income'] <= 1_000_000]

# checando porcentagem de valores nulos por coluna
dt.info()

fig, axes = plt.subplots(2, 3, figsize=(15,9))
fig.suptitle('Distriuição dos valores do dataset')

sns.histplot(dt_filtrado['Num_of_Delayed_Payment'], kde=True, ax=axes[0,0])
axes[0,0].set_title('Distribuição Quantidade de Pagamentos Atrasados')

sns.histplot(x='Num_of_Loan', data=dt_filtrado, ax=axes[0,1])
axes[0,1].set_title('Distribuição Quantidade de Empréstimos')
axes[0,1].set_xticklabels(axes[0,1].get_xticklabels(), rotation=45, ha='right')

sns.histplot(x='Interest_Rate', data=dt_filtrado, ax=axes[0,2])
axes[0,2].set_title('Distribuição de Taxa de Juros')
axes[0,2].set_xticklabels(axes[0,2].get_xticklabels(), rotation=45, ha='right')

sns.histplot(x='Num_Bank_Accounts', data=dt_filtrado, ax=axes[1,0])
axes[1,0].set_title('Distribuição de Número de Contas Bancárias')
axes[1,0].set_xticklabels(axes[1,0].get_xticklabels(), rotation=45, ha='right')

sns.histplot(x='Num_Credit_Card', data=dt_filtrado, ax=axes[1,1])
axes[1,1].set_title('Distribuição de Número de Cartões de Crédito')
axes[1,1].set_xticklabels(axes[1,1].get_xticklabels(), rotation=45, ha='right')

sns.countplot(x='Credit_Score', data=dt_filtrado, ax=axes[1,2])
axes[1,2].set_title('Distribuição de Score de Crédito')

plt.tight_layout()

fig, axes = plt.subplots(2, 3, figsize=(15,9))
fig.suptitle('Distriuição dos valores do dataset')

sns.boxplot(dt_filtrado['Num_of_Delayed_Payment'], ax=axes[0,0])
axes[0,0].set_title('Distribuição Quantidade de Pagamentos Atrasados')

sns.boxplot(x='Num_of_Loan', data=dt_filtrado, ax=axes[0,1])
axes[0,1].set_title('Distribuição Quantidade de Empréstimos')
axes[0,1].set_xticklabels(axes[0,1].get_xticklabels(), rotation=45, ha='right')

sns.boxplot(x='Interest_Rate', data=dt_filtrado, ax=axes[0,2])
axes[0,2].set_title('Distribuição de Taxa de Juros')
axes[0,2].set_xticklabels(axes[0,2].get_xticklabels(), rotation=45, ha='right')

sns.boxplot(x='Num_Bank_Accounts', data=dt_filtrado, ax=axes[1,0])
axes[1,0].set_title('Distribuição de Número de Contas Bancárias')
axes[1,0].set_xticklabels(axes[1,0].get_xticklabels(), rotation=45, ha='right')

sns.boxplot(x='Num_Credit_Card', data=dt_filtrado, ax=axes[1,1])
axes[1,1].set_title('Distribuição de Número de Cartões de Crédito')
axes[1,1].set_xticklabels(axes[1,1].get_xticklabels(), rotation=45, ha='right')

sns.countplot(x='Credit_Score', data=dt_filtrado, ax=axes[1,2])
axes[1,2].set_title('Distribuição de Score de Crédito')

plt.tight_layout()

dt_final = dt_filtrado.copy()
dt_final.replace({"Credit_Score": { "Poor": 0, "Standard": 1, "Good": 2 }}, inplace=True)

#Criando grafico de correlação para analise
correlacoes = (dt_final.corr() ** 2).round(2)

fig, ax = plt.subplots(figsize=(12, 6))

sns.heatmap(correlacoes, annot=True, linewidths=5, ax=ax)

from sklearn.preprocessing import StandardScaler, OneHotEncoder, RobustScaler, LabelEncoder, MinMaxScaler
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer


X_train = dt_final.drop(columns='Credit_Score')
y_train = dt_final['Credit_Score']

num_pipe = Pipeline([
    ('scaler', RobustScaler())
])

transformer = ColumnTransformer([
    ('num_pipe', num_pipe, ['Num_of_Delayed_Payment', 'Num_of_Loan', 'Interest_Rate', 'Num_Bank_Accounts', 'Num_Credit_Card', 'Annual_Income']),
])
transformer.fit(X_train)

column_names = transformer.get_feature_names_out()
X_train_transformed = pd.DataFrame(transformer.transform(X_train), columns=column_names)
X_train_transformed

"""# Implementação de Algoritmo Genético"""

y_train_dt = pd.DataFrame(y_train)
y_train_dt['Credit_Score'].values

import itertools

# Pygame

WIDTH, HEIGHT = 800, 400
NODE_RADIUS = 10
FPS = 30
PLOT_X_OFFSET = 450

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Otimizador de Pesos de Análise de Crédito")
clock = pygame.time.Clock()
generation_counter = itertools.count(start=1)

# Função de aptidão
def fitness_function(chromosome, y_train):
    weights = chromosome[:-2]  # Pesos das variáveis
    threshold_standard = chromosome[-2]  # Limiar de decisão standard
    threshold_good = chromosome[-1] # Limiar de decisão good
    scores = np.dot(X_train, weights)
    predictions = []
    for score in scores:
      if score >= threshold_good:
        predictions.append(2)
      elif score >= threshold_standard:
        predictions.append(1)
      else:
        predictions.append(0)
    return f1_score(y_train, predictions, average='micro')

# Inicialização da população
def initialize_population(pop_size, num_features):
    return np.random.uniform(-1, 1, (pop_size, num_features + 2))  # Inclui pesos + limiares

# Seleção por torneio
def tournament_selection(population, fitness, k=3):
    selected = np.random.choice(len(population), k, replace=False)
    best = selected[np.argmax(fitness[selected])]
    return population[best]

# TODO: 2 tipos Cruzamento
# Cruzamento
def crossover(parent1, parent2, crossover_rate=0.8):
    if np.random.rand() < crossover_rate:
        point = np.random.randint(1, len(parent1) - 1)
        child1 = np.concatenate((parent1[:point], parent2[point:]))
        child2 = np.concatenate((parent2[:point], parent1[point:]))
        return child1, child2
    return parent1, parent2

# TODO: 2 tipos de mutação
# Mutação
def mutate(chromosome, mutation_rate=0.3):
    for i in range(len(chromosome)):
        if np.random.rand() < mutation_rate:
            chromosome[i] += np.random.uniform(-0.1, 0.1)
    return chromosome

# Algoritmo Genético
def genetic_algorithm(X_train, y_train, pop_size=50, num_generations=100):
    num_features = X_train.shape[1]
    population = initialize_population(pop_size, num_features)
    best_solution = None
    best_fitness = -np.inf

    for generation in range(num_generations):
        fitness = np.array([fitness_function(ind, y_train) for ind in population])
        next_population = []

        # Seleção e reprodução
        for _ in range(pop_size // 2):
            parent1 = tournament_selection(population, fitness)
            parent2 = tournament_selection(population, fitness)
            child1, child2 = crossover(parent1, parent2)
            next_population.append(mutate(child1))
            next_population.append(mutate(child2))

        population = np.array(next_population)

        next_population.append(population[fitness.argmax()]) # Elitismo

        # TODO: Pygame + Gráfico

        # Melhor solução
        if fitness.max() > best_fitness:
            best_fitness = fitness.max()
            best_solution = population[fitness.argmax()]

        print(f"Geração {generation}: Melhor aptidão = {best_fitness:.4f}")

    return best_solution

# Executando o algoritmo genético
best_solution = genetic_algorithm(X_train_transformed, y_train_dt['Credit_Score'].values)

# Resultados
print("\nMelhor solução encontrada:")
print(f"Pesos: {best_solution[:-1]}")
print(f"Limiar de decisão: {best_solution[-1]:.4f}")

