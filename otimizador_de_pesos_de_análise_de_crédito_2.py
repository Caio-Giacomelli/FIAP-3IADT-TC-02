# -*- coding: utf-8 -*-
"""Otimizador de Pesos de Análise de Crédito - 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lPVvqU6hSxzZUiLQYmEA9ivN4b4sL_8W

# Importação de bibliotecas e dados
"""

import numpy as np
import pandas as pd
import seaborn as sns
import pygame
import streamlit as st
from pygame.locals import *
import matplotlib.pyplot as plt
from sklearn.metrics import f1_score

full_dt = pd.read_csv('https://raw.githubusercontent.com/Caio-Giacomelli/FIAP-3IADT-TC-02/refs/heads/main/credit_analysis_train.csv')

full_dt.info()

# Removendo colunas que não utilizaremos em nossa otimização
columns_to_remove = ['ID', 'Age', 'Customer_ID', 'Month', 'Name', 'SSN', 'Type_of_Loan', 'Occupation', 'Delay_from_due_date', 'Monthly_Inhand_Salary', 'Changed_Credit_Limit', 'Num_Credit_Inquiries', 'Credit_Mix', 'Credit_History_Age','Payment_of_Min_Amount','Total_EMI_per_month','Amount_invested_monthly', 'Payment_Behaviour', 'Outstanding_Debt', 'Credit_Utilization_Ratio', 'Monthly_Balance']
dt = full_dt.drop(columns=columns_to_remove)

dt.duplicated().sum()

dt.drop_duplicates(inplace=True)
# dt.shape

# Removendo valores nulos ou mal formatados

dt = dt.replace('_', '', regex=True)

# Transformando colunas de strings para numérico
dt['Num_of_Delayed_Payment'] = pd.to_numeric(dt['Num_of_Delayed_Payment'], errors='coerce')
dt['Num_of_Loan'] = pd.to_numeric(dt['Num_of_Loan'], errors='coerce')
dt['Annual_Income'] = pd.to_numeric(dt['Annual_Income'], errors='coerce')

# Removendo registros com valores discrepantes demais
dt_filtrado = dt.copy()
dt_filtrado = dt_filtrado[dt_filtrado['Num_of_Delayed_Payment'] <= 30]
dt_filtrado = dt_filtrado[(dt_filtrado['Num_of_Loan'] > 0) & (dt_filtrado['Num_of_Loan'] <= 30)]
dt_filtrado = dt_filtrado[dt_filtrado['Interest_Rate'] <= 100]
dt_filtrado = dt_filtrado[dt_filtrado['Num_Bank_Accounts'] <= 30]
dt_filtrado = dt_filtrado[dt_filtrado['Num_Credit_Card'] <= 30]
dt_filtrado = dt_filtrado[dt_filtrado['Annual_Income'] <= 1_000_000]

# dt_filtrado = dt_filtrado[dt_filtrado['Credit_Score'] != 'Standard']

# checando porcentagem de valores nulos por coluna
# dt.info()

fig, axes = plt.subplots(2, 3, figsize=(15,9))
fig.suptitle('Distriuição dos valores do dataset')

sns.histplot(dt_filtrado['Num_of_Delayed_Payment'], kde=True, ax=axes[0,0])
axes[0,0].set_title('Distribuição Quantidade de Pagamentos Atrasados')

sns.histplot(x='Num_of_Loan', data=dt_filtrado, ax=axes[0,1])
axes[0,1].set_title('Distribuição Quantidade de Empréstimos')
axes[0,1].set_xticklabels(axes[0,1].get_xticklabels(), rotation=45, ha='right')

sns.histplot(x='Interest_Rate', data=dt_filtrado, ax=axes[0,2])
axes[0,2].set_title('Distribuição de Taxa de Juros')
axes[0,2].set_xticklabels(axes[0,2].get_xticklabels(), rotation=45, ha='right')

sns.histplot(x='Num_Bank_Accounts', data=dt_filtrado, ax=axes[1,0])
axes[1,0].set_title('Distribuição de Número de Contas Bancárias')
axes[1,0].set_xticklabels(axes[1,0].get_xticklabels(), rotation=45, ha='right')

sns.histplot(x='Num_Credit_Card', data=dt_filtrado, ax=axes[1,1])
axes[1,1].set_title('Distribuição de Número de Cartões de Crédito')
axes[1,1].set_xticklabels(axes[1,1].get_xticklabels(), rotation=45, ha='right')

sns.countplot(x='Credit_Score', data=dt_filtrado, ax=axes[1,2])
axes[1,2].set_title('Distribuição de Score de Crédito')

plt.tight_layout()

fig, axes = plt.subplots(2, 3, figsize=(15,9))
fig.suptitle('Distriuição dos valores do dataset')

sns.boxplot(dt_filtrado['Num_of_Delayed_Payment'], ax=axes[0,0])
axes[0,0].set_title('Distribuição Quantidade de Pagamentos Atrasados')

sns.boxplot(x='Num_of_Loan', data=dt_filtrado, ax=axes[0,1])
axes[0,1].set_title('Distribuição Quantidade de Empréstimos')
axes[0,1].set_xticklabels(axes[0,1].get_xticklabels(), rotation=45, ha='right')

sns.boxplot(x='Interest_Rate', data=dt_filtrado, ax=axes[0,2])
axes[0,2].set_title('Distribuição de Taxa de Juros')
axes[0,2].set_xticklabels(axes[0,2].get_xticklabels(), rotation=45, ha='right')

sns.boxplot(x='Num_Bank_Accounts', data=dt_filtrado, ax=axes[1,0])
axes[1,0].set_title('Distribuição de Número de Contas Bancárias')
axes[1,0].set_xticklabels(axes[1,0].get_xticklabels(), rotation=45, ha='right')

sns.boxplot(x='Num_Credit_Card', data=dt_filtrado, ax=axes[1,1])
axes[1,1].set_title('Distribuição de Número de Cartões de Crédito')
axes[1,1].set_xticklabels(axes[1,1].get_xticklabels(), rotation=45, ha='right')

sns.countplot(x='Credit_Score', data=dt_filtrado, ax=axes[1,2])
axes[1,2].set_title('Distribuição de Score de Crédito')

plt.tight_layout()

dt_final = dt_filtrado.copy()
dt_final.replace({"Credit_Score": { "Poor": 0, "Standard": 1, "Good": 2 }}, inplace=True)

#Criando grafico de correlação para analise
correlacoes = (dt_final.corr() ** 2).round(2)

fig, ax = plt.subplots(figsize=(12, 6))

sns.heatmap(correlacoes, annot=True, linewidths=5, ax=ax)

from sklearn.preprocessing import StandardScaler, OneHotEncoder, RobustScaler, LabelEncoder, MinMaxScaler
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer


X_train = dt_final.drop(columns='Credit_Score')
y_train = dt_final['Credit_Score']

num_pipe = Pipeline([
    ('scaler', RobustScaler())
])

transformer = ColumnTransformer([
    ('num_pipe', num_pipe, ['Num_of_Delayed_Payment', 'Num_of_Loan', 'Interest_Rate', 'Num_Bank_Accounts', 'Num_Credit_Card', 'Annual_Income']),
])
transformer.fit(X_train)

column_names = transformer.get_feature_names_out()
X_train_transformed = pd.DataFrame(transformer.transform(X_train), columns=column_names)
# X_train_transformed

from scipy.special import expit  # Função sigmoid eficiente

y_train_dt = pd.DataFrame(y_train)
# y_train_dt['Credit_Score'].values

# import itertools

# Pygame

WIDTH, HEIGHT = 800, 600
FPS = 30
GRAPH_WIDTH = 600
GRAPH_HEIGHT = 400
GRAPH_OFFSET_X = 100
GRAPH_OFFSET_Y = 100

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Crescimento da Melhor Aptidão - Algoritmo Genético")
clock = pygame.time.Clock()

# Função para desenhar o gráfico
def draw_graph(screen, fitness_history):
    screen.fill((255, 255, 255))  # Fundo branco
    pygame.draw.rect(screen, (0, 0, 0), (GRAPH_OFFSET_X, GRAPH_OFFSET_Y, GRAPH_WIDTH, GRAPH_HEIGHT), 2)  # Moldura do gráfico

    if len(fitness_history) > 1:
        max_fitness = max(fitness_history)
        min_fitness = min(fitness_history)
        scale_x = GRAPH_WIDTH / len(fitness_history)
        scale_y = GRAPH_HEIGHT / (max_fitness - min_fitness) if max_fitness != min_fitness else 1

        for i in range(1, len(fitness_history)):
            x1 = GRAPH_OFFSET_X + (i - 1) * scale_x
            y1 = GRAPH_OFFSET_Y + GRAPH_HEIGHT - (fitness_history[i - 1] - min_fitness) * scale_y
            x2 = GRAPH_OFFSET_X + i * scale_x
            y2 = GRAPH_OFFSET_Y + GRAPH_HEIGHT - (fitness_history[i] - min_fitness) * scale_y
            pygame.draw.line(screen, (255, 0, 0), (x1, y1), (x2, y2), 2)  # Linha do gráfico

    pygame.display.flip()

# Função de aptidão
def fitness_function(chromosome, y_train):

    ## Versão com 1 limiar
    # weights = chromosome[:-1]  # Pesos das variáveis
    # threshold = chromosome[-1]  # Limiar de decisão
    # scores = expit(np.dot(X_train_transformed, weights))
    # predictions = (scores >= threshold).astype(int)

    # return f1_score(y_train, predictions, average='micro')

    weights = chromosome[:-2]  # Pesos das variáveis
    threshold_standard = chromosome[-2]  # Limiar de decisão standard
    threshold_good = chromosome[-1] # Limiar de decisão good
    scores = expit(np.dot(X_train_transformed, weights))
    predictions = []
    for score in scores:
      if score >= threshold_good:
        predictions.append(2)
      elif score >= threshold_standard:
        predictions.append(1)
      else:
        predictions.append(0)
    return f1_score(y_train, predictions, average='micro')


# Inicialização da população
def initialize_population(pop_size, num_features):
    return np.random.uniform(-1, 1, (pop_size, num_features + 2))  # Inclui pesos + limiares

# Seleção por torneio
def tournament_selection(population, fitness, k=3):
    selected = np.random.choice(len(population), k, replace=False)
    best = selected[np.argmax(fitness[selected])]
    return population[best]

# Seleção por ranking
def ranking_selection(population, fitness):

    ranked_indices = np.argsort(fitness)
    probabilities = np.linspace(0, 1, len(fitness))
    probabilities /= probabilities.sum()

    # Escolher um indivíduo baseado nas probabilidades do ranking
    selected_index = np.random.choice(ranked_indices, p=probabilities)
    return population[selected_index]


# Cruzamento - Single Point Crossover
def crossover(parent1, parent2, crossover_rate=0.8):
    if np.random.rand() < crossover_rate:
        point = np.random.randint(1, len(parent1) - 1)
        child1 = np.concatenate((parent1[:point], parent2[point:]))
        child2 = np.concatenate((parent2[:point], parent1[point:]))
        return child1, child2
    return parent1, parent2

# Cruzamento Aritmético
def arithmetic_crossover(parent1, parent2, crossover_rate=0.8, alpha=0.5):
    if np.random.rand() < crossover_rate:
        child1 = alpha * parent1 + (1 - alpha) * parent2
        child2 = alpha * parent2 + (1 - alpha) * parent1
        return child1, child2
    return parent1, parent2

# Mutação com perturbação uniforme
def mutate(chromosome, mutation_rate=0.5):
    for i in range(len(chromosome)):
        if np.random.rand() < mutation_rate:
            chromosome[i] += np.random.uniform(-0.1, 0.1)
    return chromosome

# Perturbação Gaussiana
def gaussian_mutate(chromosome, mutation_rate=0.5, sigma=0.1):
    for i in range(len(chromosome)):
        if np.random.rand() < mutation_rate:
            chromosome[i] += np.random.normal(0, sigma)  # Perturbação Gaussiana
    return chromosome

# Algoritmo Genético
def genetic_algorithm(X_train, y_train, pop_size=50, num_generations=100):
    num_features = X_train.shape[1]

    population = initialize_population(pop_size, num_features)
    best_solution = None
    best_fitness = -np.inf

    for generation in range(num_generations):
        fitness = np.array([fitness_function(ind, y_train) for ind in population])

        next_population = []

        # Seleção e reprodução
        for _ in range(pop_size // 2):
            parent1 = tournament_selection(population, fitness)
            parent2 = tournament_selection(population, fitness)
            child1, child2 = crossover(parent1, parent2)
            next_population.append(mutate(child1))
            next_population.append(mutate(child2))

        next_population.append(population[fitness.argmax()]) # Elitismo
        population = np.array(next_population)

        # TODO: Pygame + Gráfico

        # Melhor solução
        if fitness.max() > best_fitness:
            best_fitness = fitness.max()
            best_solution = population[fitness.argmax()]

        print(f"Geração {generation}: Melhor aptidão = {best_fitness:.4f}")

    return best_solution

def genetic_algorithm_streamlit(X_train, y_train, pop_size=10, num_generations=10):
    num_features = X_train.shape[1]
    population = initialize_population(pop_size, num_features)
    best_solution = None
    best_fitness = -np.inf
    fitness_history = []

    for generation in range(num_generations):
        fitness = np.array([fitness_function(ind, y_train) for ind in population])
        fitness_history.append(fitness.max())

        next_population = []

        # Seleção e reprodução
        for _ in range(pop_size // 2):
            parent1 = tournament_selection(population, fitness)
            parent2 = tournament_selection(population, fitness)
            child1, child2 = crossover(parent1, parent2)
            next_population.append(mutate(child1))
            next_population.append(mutate(child2))

        next_population.append(population[fitness.argmax()])  # Elitismo
        population = np.array(next_population)

        # Melhor solução
        if fitness.max() > best_fitness:
            best_fitness = fitness.max()
            best_solution = population[fitness.argmax()]

        # Atualizar gráfico no Streamlit
        st.line_chart(fitness_history)

        st.write(f"Geração {generation + 1}: Melhor aptidão = {best_fitness:.4f}")

    return best_solution

# Dados de entrada (carregue seu dataset aqui)
# X_train_transformed e y_train_dt precisam estar definidos
# Exemplo:
# X_train_transformed = ...
# y_train_dt = ...

# Interface Streamlit
st.title("Algoritmo Genético com Visualização no Streamlit")
pop_size = st.sidebar.slider("Tamanho da população", min_value=10, max_value=200, value=50, step=10)
num_generations = st.sidebar.slider("Número de gerações", min_value=10, max_value=500, value=100, step=10)

if st.button("Iniciar Algoritmo Genético"):
    best_solution = genetic_algorithm_streamlit(
        X_train_transformed, y_train_dt["Credit_Score"].values, pop_size=pop_size, num_generations=num_generations
    )
    st.write("Melhor solução encontrada:")
    st.write(f"Pesos: {best_solution[:-2]}")
    st.write(f"Limiar de decisão Standard: {best_solution[-2]:.4f}")
    st.write(f"Limiar de decisão Good: {best_solution[-1]:.4f}")
